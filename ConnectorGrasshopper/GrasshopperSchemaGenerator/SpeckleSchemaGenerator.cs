using System;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Speckle.Core.Kits;
using ConnectorGrasshopperUtils;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerator
{
  public static class SpeckleDiagnostics
  {
    private static string prefix = "SPKL";
    private static string category = "Code Generation";

    private static DiagnosticDescriptor GetDescriptor(string id, string title, string description,
      DiagnosticSeverity severity = DiagnosticSeverity.Info) => new(
      $"{prefix}{id}",
      title,
      $"{{0}}: [{prefix}{id}] {{1}}",
      category,
      severity,
      true,
      description);

    public static DiagnosticDescriptor SuccessInfo =
      GetDescriptor("001", "Successfully generated file", "A file was added during compilation");

    public static DiagnosticDescriptor ExceptionError = GetDescriptor("002", "Error generating file",
      "An error occurred while generating code during compliation");

    public static Diagnostic CreateSuccessDiagnostic(string fileName) => Diagnostic.Create(
      SuccessInfo,
      Location.Create(
        fileName,
        new TextSpan(0, 0),
        new LinePositionSpan(new LinePosition(0, 0), new LinePosition(0, 0))
      ),
      new object[] { fileName, SuccessInfo.Description }
    );

    public static Diagnostic CreateErrorDiagnostic(string fileName, Exception e, GeneratorExecutionContext context) =>
      Diagnostic.Create(
        ExceptionError,
        Location.Create(
          fileName,
          new TextSpan(0, 0),
          new LinePositionSpan(new LinePosition(0, 0), new LinePosition(0, 0))
        ),
        new object[] { fileName, ExceptionError.Id, e.Message }
      );
  }

  [Generator]
  public class SpeckleSchemaSourceCodeGenerator : ISourceGenerator
  {
    public void Execute(GeneratorExecutionContext context)
    {
      CSOUtils.ListAvailableTypes().ForEach(t =>
      {
        try
        {
          // Add the source code to the compilation
          var name = $"{t.Name}SchemaNode.g.cs";
          context.AddSource(name, BuildSource(t));
          context.ReportDiagnostic(SpeckleDiagnostics.CreateSuccessDiagnostic(name));
        }
        catch (Exception e)
        {
          Console.WriteLine(e);
          throw;
        }
      });
    }

    public void Initialize(GeneratorInitializationContext context)
    {
#if DEBUG
      //SpinWait.SpinUntil(() => Debugger.IsAttached);
#endif
      var pt = new Objects.Geometry.Point(0, 0);
      Debug.WriteLine(pt);
    }

    static string oldSecret = "secretPhraseToKeepItRandom...";
    static string newSecret = "theBrandNewV2RandomPhrase";

    public static string ToNewGuid(string input) => ToGuid(input, newSecret).ToString();
    public static string ToOldGuid(string input) => ToGuid(input, oldSecret).ToString();


    public static Guid ToGuid(string input, string secret)
    {
      var src = secret + input;
      byte[] stringbytes = Encoding.UTF8.GetBytes(src);
      byte[] hashedBytes = new System.Security.Cryptography
          .SHA1CryptoServiceProvider()
        .ComputeHash(stringbytes);
      Array.Resize(ref hashedBytes, 16);
      return new Guid(hashedBytes);
    }

    private static string BuildSource(Type t)
    {
      return $@"//<auto-generated/>
using System;
using System.Linq;
using Grasshopper.Kernel;
using ConnectorGrasshopperUtils;
using ConnectorGrasshopper;

namespace ConnectorGrasshopper.SchemaNodes.AutoGenerated {{
    {BuildSchemaComponentClassesForType(t)}
    {BuildUpgraderClassesForType(t)}
}}
";
    }

    private static string BuildUpgraderClassesForType(Type t)
    {
      var cs = CSOUtils.GetValidConstr(t);
      var upgraders = cs.Select(c =>
      {
        var fullName = CSOUtils.MethodFullName(c);
        var oldGuid = ToOldGuid(fullName);
        var newGuid = ToNewGuid(fullName);
        var name = GetClassName(t, newGuid);

        return BuildUpgraderClass(name, oldGuid, newGuid);
      });
      return string.Join("\n", upgraders);
    }

    private static string BuildSchemaComponentClassesForType(Type t)
    {
      var strings = CSOUtils
        .GetValidConstr(t)
        .Select(c =>
        {
          var info = c.GetCustomAttributes(typeof(SchemaInfo), false).First() as SchemaInfo;
          return info == null
            ? string.Empty
            : BuildSchemaComponentClass(t, info, c);
        });
      return string.Join("\n", strings);
    }

    private static string BuildSchemaComponentClass(Type type, SchemaInfo info, ConstructorInfo c)
    {
      var fullName = CSOUtils.MethodFullName(c);
      var guid = ToNewGuid(fullName);
      var className = GetClassName(type, guid);
      return $@"
    public class {className}: CreateSchemaObjectBase {{
        {BuildStaticConstructor(className)}
        
        public {className}(): base(""{info.Name}"", ""{info.Name}"", ""{info.Description}"", ""{info.Category}"", ""{info.Subcategory}""){{}}
        
        internal static string internalCategory => ""Speckle 2 Autogenerated"";
        internal static Guid internalGuid => new Guid(""{guid}"");
        internal static GH_Exposure internalExposure => GH_Exposure.tertiary;

        public override GH_Exposure Exposure => internalExposure;
        public override Guid ComponentGuid => internalGuid;

        public override void AddedToDocument(GH_Document document){{
          SelectedConstructor = CSOUtils.FindConstructor(""{fullName}"", ""{c.DeclaringType!.FullName}"");
          base.AddedToDocument(document);
        }}
    }}";
    }

    private static string GetClassName(Type type, string guid)
    {
      return type.Name + "_" + guid.Replace("-", "_");
    }

    private static string BuildStaticConstructor(string name)
    {
      return $@"
        static {name}() {{
          SpeckleGHSettings.SettingsChanged += (_, args) =>
          {{
            if (!args.Key.StartsWith(""Speckle2:tabs."")) return;
            var proxy = Grasshopper.Instances.ComponentServer.ObjectProxies.FirstOrDefault(p => p.Guid == internalGuid);
            if (proxy == null) return;
            proxy.Exposure = internalExposure;
          }};
        }}";
    }

    private static string BuildUpgraderClass(string name, string oldGuid, string newGuid)
    {
      return $@"
    public class {name}UpgraderObject: IGH_UpgradeObject
    {{
        public IGH_DocumentObject Upgrade(IGH_DocumentObject target, GH_Document document)
        {{
          var component = target as IGH_Component;
          if (component == null)
            return null;

          var upgradedComponent = GH_UpgradeUtil.SwapComponents(component, UpgradeTo);
          UpgradeUtils.SwapGroups(document, component, upgradedComponent);
          return upgradedComponent;
        }}

        public DateTime Version => new DateTime(2023, 3, 1);

        public Guid UpgradeFrom => new Guid(""{oldGuid}"");
        public Guid UpgradeTo => new(""{newGuid}"");
    }}
";
    }
  }
}
